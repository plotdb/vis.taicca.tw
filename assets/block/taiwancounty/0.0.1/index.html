<div><div plug="layout"><div class="pdl-layout"><div data-type="layout"><div class="pdl-cell" data-name="view"></div><div class="pdl-cell" data-name="legend">123</div></div><div data-type="render"></div></div></div><style type="text/css">.pdl-layout > div[data-type=layout] {
  display: grid;
  grid-template-columns: 1fr fit-content(5em);
}
</style><script type="@plotdb/block">var mod;
module.exports = {
  pkg: {
    name: 'taiwancounty',
    version: '0.0.1',
    extend: {
      name: "base",
      version: "0.0.1"
    },
    dependencies: [
      {
        url: "https://d3js.org/topojson.v2.min.js",
        async: false
      }, {
        url: "https://d3js.org/d3-geo.v2.min.js",
        async: false
      }, {
        name: "pdmaptw",
        version: "main",
        path: "index.min.js",
        async: false
      }, {
        name: "pdmaptw",
        version: "main",
        path: "county.map.js"
      }
    ]
  },
  init: function(arg$){
    var root, context, pubsub;
    root = arg$.root, context = arg$.context, pubsub = arg$.pubsub;
    return pubsub.fire('init', {
      mod: mod({
        context: context
      })
    }).then(function(it){
      return it[0];
    });
  }
};
mod = function(arg$){
  var context, chart, d3, ldcolor, pdmaptw, topojson;
  context = arg$.context;
  chart = context.chart, d3 = context.d3, ldcolor = context.ldcolor, pdmaptw = context.pdmaptw, topojson = context.topojson;
  return {
    sample: function(){
      return pdmaptw.get('county').then(function(arg$){
        var meta, topo;
        meta = arg$.meta, topo = arg$.topo;
        return {
          raw: meta.name.map(function(it){
            return {
              val: Math.random(),
              name: pdmaptw.normalize(it)
            };
          }),
          binding: {
            color: {
              key: 'val'
            },
            name: {
              key: 'name'
            }
          }
        };
      });
    },
    config: {
      palette: {
        type: 'palette'
      }
    },
    dimension: {
      name: {
        type: 'N',
        name: "國家"
      },
      color: {
        type: 'R',
        name: "顏色"
      }
    },
    init: function(){
      var scale, this$ = this;
      this.g = this.layout.getGroup('view');
      this.obj = new pdmaptw({
        root: this.g,
        type: 'county'
      });
      this.scale = scale = {
        color: d3.interpolateTurbo
      };
      this.legend = new chart.utils.legend({
        root: this.root,
        name: 'legend',
        layout: this.layout,
        shape: function(d){
          return d3.select(this).attr('fill', scale.color(d.key));
        }
      });
      this.tip = new chart.utils.tip({
        root: this.root,
        accessor: function(arg$){
          var evt, data;
          evt = arg$.evt;
          if (!(evt.target && (data = d3.select(evt.target).datum()))) {
            return null;
          }
          return {
            name: data.data.name,
            value: data.data.color
          };
        },
        range: function(){
          return this$.layout.getNode('view').getBoundingClientRect();
        }
      });
      return this.obj.init().then(function(){
        return this$.obj.fit({
          node: this$.g,
          box: this$.layout.getNode('view').getBoundingClientRect()
        });
      });
    },
    parse: function(){
      var this$ = this;
      this.extent = {
        c: [undefined, undefined]
      };
      return d3.select(this.svg).selectAll('path').each(function(d, i){
        d.data = this$.data.filter(function(it){
          return it.name === d.properties.name;
        })[0] || {};
        if (!(this$.extent.c[0] != null) || d.data.color < this$.extent.c[0]) {
          this$.extent.c[0] = d.data.color;
        }
        if (!(this$.extent.c[1] != null) || d.data.color > this$.extent.c[1]) {
          return this$.extent.c[1] = d.data.color;
        }
      });
    },
    resize: function(){
      var ref$, pal, len, this$ = this;
      this.tip.toggle(((ref$ = this.cfg).tip || (ref$.tip = {})).enabled != null ? this.cfg.tip.enabled : true);
      this.obj.fit(this.layout.getBox('view'));
      pal = this.cfg.palette
        ? this.cfg.palette.colors
        : ['#f00', '#999', '#00f'];
      len = pal.length;
      this.ticks = d3.quantize(function(it){
        return (1 - it) * (this$.extent.c[1] - this$.extent.c[0]) + this$.extent.c[0];
      }, len).map(function(it){
        var that;
        return {
          key: it,
          text: d3.format(this$.cfg.legendFormat || '.2f')(it) + ((that = this$.binding.color.unit) ? that : '')
        };
      });
      this.ticks.sort(function(a, b){
        return a.key - b.key;
      });
      if (this.cfg.palette) {
        this.scale.color = d3.scaleLinear().domain(this.ticks.map(function(it){
          return it.key;
        })).range(pal.map(function(it){
          return ldcolor.web(it.value || it);
        }));
      }
      this.legend.data(this.ticks);
      return this.obj.fit({
        node: this.g,
        box: this.layout.getBox('view')
      });
    },
    render: function(){
      var this$ = this;
      d3.select(this.svg).selectAll('path').transition().duration(350).attr('fill', function(d, i){
        return this$.scale.color(d.data.color);
      }).attr('fill-opacity', function(d, i){
        if (this$.cfg.dimEmpty) {
          if (d.data.color != null) {
            return 1;
          } else {
            return 0.2;
          }
        } else {
          return 1;
        }
      });
      return this.legend.render();
    }
  };
};</script></div>